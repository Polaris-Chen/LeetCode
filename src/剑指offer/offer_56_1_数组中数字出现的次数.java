package 剑指offer;

/**
 * @author polarisChen
 * @create 2021/3/9 3:04 下午
 */
public class offer_56_1_数组中数字出现的次数 {
    /*
     * & 与运算 两个操作数中位都为1，结果才为1，否则结果为0
     * | 或运算 两个位只要有一个为1，那么结果就是1，否则就为0
     * ~ 非运算 如果位为0，结果是1，如果位为1，结果是0
     * ^ 异或运算 两个操作数的位中，相同则结果为0，不同则结果为1
     *
     * 本题的思路就是 两个相同的数进行异或运算结果一定是0,因此如果数组中只有一个没重复的数的话直接全部异或一遍就可以了
     * 但是现在总共有两个,那么我一定要分成两个数组来进行异或运算,有两个要求 1.两个没重复的数 a,b必须分别在两个数组里
     * 2.重复的数必须在同一个数组里
     * 算法总共分三步
     * 1.先遍历一遍,得到a^b 这个值我们不知道是多少,但是可以用来判断ab哪一位不一样
     * 2.使用与运算找到第一次ab不一样的那位
     * 3.用ab不一样的那位作为分类器,比如 a是101100 b是110000 ab不一样的那位是第3位 那我的分类器就是 100
     * 此时我们可以看到 a,b和这个分类器进行与运算得到的结果一定不一样,就实现了a,b落在两个数组里的目的
     * 同时 相同的数和分类器与运算得到的结果肯定一样,也会落在一个数组里,然后直接全部与运算就可以得到结果了
     * */
    public int[] singleNumbers(int[] nums) {
        //a^b的结果
        int a_b = 0;
        //分类器
        int m = 1;
        int a = 0;
        int b = 0;
        //先循环一次得到a^b的值
        for (int x : nums) {
            a_b ^= x;
        }
        //找到分类器
        //(a_b & m) == 0的含义是 ab在这一位上是相同的
        //因此跳出循环的时候就是找到了从右到左第一个不相同的位置
        //m就是 1,10,100,1000,10000这样不断尝试
        while ((a_b & m) == 0) {
            //左移一位
            m <<= 1;
        }
        for (int x : nums) {
            //这里等于0或者不等于0都无所谓,只是为了分类而已
            if ((m & x) == 0) {
                a ^= x;
            } else {
                b ^= x;
            }
        }
        return new int[]{a, b};
    }
}
